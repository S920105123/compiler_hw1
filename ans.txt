1:pragma source on
2:pragma token on
 23.4
1234
23@23

i can't see you #id:hi
#id:hi
#op:=
#id:qq
3:*/ hi hi = qq
4:// 234 sdf  ewe int double void
#char:''
5:''
#string:
6:""
#string: \
#string: av c
#string:sdf
7:" \" " av c" "sdf "
8:pragma token on
#double:00000.000000
#double:02.
#id:aa
#punc:}
#id:bb
13:pragma source on
#id:aa_bb_sd__
#punc:{
#id:sdfsdf
#op:+
#id:dfsdfsd
#op:+
#id:dsf
#punc:}
14:aa_bb_sd__{sdfsdf+dfsdfsd+dsf}
#op:*
#punc:(
#punc:(
#id:apple
#punc:)
#punc:)
#punc:)
15:*((apple)))
#double:12.34
16:12.34
#sci:123.34e234
17:123.34e234
#op:&
18:&
#key:for
#punc:(
#key:int
#id:i
#op:=
#integer:0
#punc:;
#id:i
#op:>
#id:oo
#punc:;
#id:i
#op:+
#op:=
IDDerror
Error at line 19: 2oo){
#id:cout
#op:<
#op:<
#id:i
#op:*
#id:pow
#punc:(
#id:oo
#punc:,
#id:oo
#punc:)
#punc:;
20:    cout << i*pow(oo, oo);
#punc:}
21:}
#double:.00
22:.00
#double:.10
23:.10
#sci:23.23e324
#op:/
#integer:34
#id:good
24:23.23e324/34     good
#sci:23.23e324
#op:++
#integer:34
#id:good
25:23.23e324++34   good
#sci:23.23e324
#op:--
#integer:34
#id:good
26:23.23e324--34   good
#sci:23.23e324
#op:&
#integer:34
#id:good
27:23.23e324&34    good
#sci:23.23e324
#op:&
#integer:34
#id:good
28:23.23e324&34    good
#sci:23.23e324
#punc:[
#integer:34
#id:good
29:23.23e324[34    good
#id:abc
#op:+
#punc:.
#id:sdf
#id:good
30:abc+.sdf        good
#id:abc
#op:+
#punc:.
#id:sdf
#id:good
31:abc+.sdf        good
#id:abc12
#double:.34
#id:good
#id:id
#punc::
#id:abc12
#key:double
#double:.34
32:abc12.34        good    id:abc12 double.34
#double:123.
#punc:.
#id:good
33:123..           good
#id:abcc
#op:*
#op:+
#id:q0_0q
#op:+
#op:*
#id:abcc
#id:good
34:abcc*+q0_0q+*abcc      good
#punc::
#punc:)
#id:good
35::) good
#punc::
#punc:(
#id:good
36::( good
#op:--
#punc:(
#id:GGqaq
#punc:)
#op:--
#id:good
37:--(GGqaq)-- good
#double:2.
#id:e
#op:++
#integer:324
#id:not
#id:sure
38:2.e++324                not sure
#sci:234.3324e-324
#punc:}
#sci:3.234e-009
#id:good
39:234.3324e-324}3.234e-009 good
#sci:234.3324e-324
#punc::
#sci:3.234e-009
#id:good
40:234.3324e-324:3.234e-009 good
#sci:234.3324e-324
#punc:;
#sci:3.234e-009
#id:good
41:234.3324e-324;3.234e-009 good
#sci:234.3324e-324
#punc:,
#sci:3.234e-009
#id:good
42:234.3324e-324,3.234e-009 good
#sci:234.3324e-324
#punc:[
#sci:3.234e-009
#id:good
43:234.3324e-324[3.234e-009 good
#sci:234.3324e-324
#punc:]
#sci:3.234e-009
#id:good
44:234.3324e-324]3.234e-009 good
#sci:234.3324e-324
#punc:(
#sci:3.234e-009
#id:good
45:234.3324e-324(3.234e-009 good
#sci:234.3324e-324
#punc:)
#sci:3.234e-009
#id:good
46:234.3324e-324)3.234e-009 good
#sci:234.3324e-324
#punc:{
#sci:3.234e-009
#id:good
47:234.3324e-324{3.234e-009 good
#sci:234.3324e-324
#punc:}
#sci:3.234e-009
#id:good
48:234.3324e-324}3.234e-009 good
#sci:234.3324e-324
#op:+
#sci:3.234e-009
#id:good
49:234.3324e-324+3.234e-009 good
#sci:234.3324e-324
#op:-
#sci:3.234e-009
#id:good
50:234.3324e-324-3.234e-009 good
#sci:234.3324e-324
#op:*
#sci:3.234e-009
#id:good
51:234.3324e-324*3.234e-009 good
#sci:234.3324e-324
#op:/
#sci:3.234e-009
#id:good
52:234.3324e-324/3.234e-009 good
#sci:234.3324e-324
#op:%
#sci:3.234e-009
#id:good
53:234.3324e-324%3.234e-009 good
#sci:234.3324e-324
#op:++
#sci:3.234e-009
#id:good
54:234.3324e-324++3.234e-009 good
#sci:234.3324e-324
#op:--
#sci:3.234e-009
#id:good
55:234.3324e-324--3.234e-009 good
#sci:234.3324e-324
#op:<
#sci:3.234e-009
#id:good
56:234.3324e-324<3.234e-009 good
#sci:234.3324e-324
#op:<=
#sci:3.234e-009
#id:good
57:234.3324e-324<=3.234e-009 good
#sci:234.3324e-324
#op:>
#sci:3.234e-009
#id:good
58:234.3324e-324>3.234e-009 good
#sci:234.3324e-324
#op:>=
#sci:3.234e-009
#id:good
59:234.3324e-324>=3.234e-009 good
#sci:234.3324e-324
#op:==
#sci:3.234e-009
#id:good
60:234.3324e-324==3.234e-009 good
#sci:234.3324e-324
#op:!=
#sci:3.234e-009
#id:good
61:234.3324e-324!=3.234e-009 good
#sci:234.3324e-324
#op:=
#sci:3.234e-009
#id:good
62:234.3324e-324=3.234e-009 good
#sci:234.3324e-324
#op:&&
#sci:3.234e-009
#id:good
63:234.3324e-324&&3.234e-009 good
#sci:234.3324e-324
#op:&
#sci:3.234e-009
#id:good
64:234.3324e-324&3.234e-009 good
#sci:234.3324e-324
#op:||
#sci:3.234e-009
#id:good
65:234.3324e-324||3.234e-009 good
#sci:234.3324e-324
#op:!
#sci:3.234e-009
#id:good
66:234.3324e-324!3.234e-009 good
#sci:234.3324e-324
#op:&
#sci:3.234e-009
#id:good
67:234.3324e-324&3.234e-009 good
#sci:234.3324e-324
Error at line 68: |3.234e-009 not sure
#sci:234.3324e-324
Error at line 69: ^3.234e-009 not sure
#sci:234.3324e-324
Error at line 70: ?3.234e-009 not sure
#sci:234.3324e-324
Error at line 71: @3.234e-009 not sure Error 234.3324e-324@3.234e-009 or @3.234e-009
#sci:234.3324e-324
Error at line 72: ~3.234e-009 not sure Error 234.3324e-324@3.234e-009
#id:se3
#double:.343
73:se3.343
#sci:2.e343
#id:not
#id:sure
74:2.e343          not sure
Error at line 75: "asdb           error
#integer:123234
Error at line 76: @123      error int: 123213 , Error@123
IDDerror
Error at line 77: 45ab2           error
Error at line 78: 10.56.23        error
Error at line 79: 12.3E+asb2      error
Error at line 80: â€œabcdefg        error
Error at line 81: @error          error
Error at line 82: #prag           error
IDDerror2
Error at line 83: abc@abc12       error  Error abc@abc12
#sci:23.23E+333
Error at line 84: @     error
Error at line 85: 23.23E+@        error
Error at line 86: 23.E@           error
Error at line 87: .23.            error
Error at line 88: 23.23.34.345.   error
Error at line 89: 123..234        error
#sci:23.23e324
Error at line 90: #34    error
#sci:23.23e324
#double:.34
#id:error
#op:-
#op:>
#id:good
91:23.23e324.34    error -> good
IDDerror2
Error at line 92: abc#sdf         error
Error at line 93: 1.12.1.1        error
#sci:123.E+2
#id:abc
#id:good
94:123.E+2abc      good
#id:abc
#punc:{
#id:abc
#id:good
95:abc{abc         good
IDDerror2
Error at line 96: abc@abc         error Error abc@abc
#integer:234
Error at line 97: #3333        error Error #3333
#sci:234.e34324
Error at line 98: #3333 not sure Error #3333
#char:'@'
99:'@'
#char:'\n'
100:'\n'
#char:'\t'
101:'\t'
#char:' '
102:' '
Error at line 103: '23423423'
#string:sdfsd
#id:sdfs
Error at line 104: "
#string:abc
#string:dfef
105:"abc" "dfef"
#string:avc\
106:"avc\"
#key:struct
#id:Node
#punc:{
107:struct Node{
#id:Node
#op:*
#id:left
#punc:,
#op:*
#id:right
#punc:;
108:    Node* left, *right;
#key:int
#id:val
#punc:;
109:    int val;
#id:Node
#punc:(
#key:int
#id:_val
#punc:)
#punc::
#id:left
#punc:(
#id:NULL
#punc:)
#punc:,
#id:right
#punc:(
#id:NULL
#punc:)
#punc:,
#id:val
#punc:(
#id:v
#punc:)
#punc:{
#punc:}
110:    Node(int _val):left(NULL), right(NULL), val(v){}
111:
#id:static
#id:Node
#op:*
#id:build
#punc:(
#key:int
#id:l
#punc:,
#key:int
#id:r
#punc:)
#punc:{
112:    static Node* build(int l, int r){
#key:if
#punc:(
#id:l
#op:==
#id:r
#punc:)
#key:return
#id:new
#id:Node
#punc:(
#id:d
#punc:[
#id:id
#punc:]
#punc:)
#punc:;
113:        if(l==r) return new Node(d[id]);
#key:else
#punc:{
114:        else{
#key:int
#id:mid
#op:=
#punc:(
#id:l
#op:+
#id:r
#punc:)
#punc:;
115:            int mid = (l+r);
#id:Node
#op:*
#id:l
#op:=
#id:new
#id:Node
#punc:;
116:            Node* l = new Node;
#id:node
#op:-
#op:>
#id:l
#op:=
#id:build
#punc:(
#id:l
#punc:,
#id:mid
#punc:)
#punc:;
117:            node->l = build(l, mid);
#id:node
#op:-
#op:>
#id:r
#op:=
#id:build
#punc:(
#id:mid
#op:+
#integer:1
#punc:,
#id:r
#punc:)
#punc:;
118:            node->r = build(mid+1, r);
#punc:}
119:        }
#punc:}
120:    }
#punc:}
#punc:;
121:};
#id:using
#id:namespace
#id:std
#punc:;
122:using namespace std;
123:
#key:const
#key:double
#id:INF
#op:=
#id:DBL_MAX
#punc:;
124:const double INF = DBL_MAX;
#key:const
#key:double
#id:eps
#op:=
#sci:1e-10
#punc:;
125:const double eps = 1e-10;
#key:const
#key:int
#id:maxn
#op:=
#integer:100
#op:+
#integer:10
#punc:;
126:const int maxn = 100+10;
#id:template
#op:<
#id:class
#id:T
#op:>
127:template<class T>
#key:struct
#id:KM
128:struct KM
#punc:{
129:{
#id:T
#id:G
#punc:[
#id:maxn
#punc:]
#punc:[
#id:maxn
#punc:]
#punc:;
130:    T G[maxn][maxn];
#id:T
#id:lx
#punc:[
#id:maxn
#punc:]
#punc:,
#id:ly
#punc:[
#id:maxn
#punc:]
#punc:,
#id:y_slack
#punc:[
#id:maxn
#punc:]
#punc:;
131:    T lx[maxn], ly[maxn], y_slack[maxn];
#key:int
#id:x_match
#punc:[
#id:maxn
#punc:]
#punc:,
#id:y_match
#punc:[
#id:maxn
#punc:]
#punc:;
132:    int x_match[maxn], y_match[maxn];
#key:int
#id:px
#punc:[
#id:maxn
#punc:]
#punc:,
#id:py
#punc:[
#id:maxn
#punc:]
#punc:;
133:    int px[maxn], py[maxn];  // keep augmenting path
#key:int
#id:y_par
#punc:[
#id:maxn
#punc:]
#punc:;
134:    int y_par[maxn]; // the x making the lowest slack to y
#key:int
#id:n
#punc:;
135:    int n;
136:
#key:void
#id:toggle
#punc:(
#key:int
#id:y
#punc:)
#punc:{
137:    void toggle(int y){
#id:x_match
#punc:[
#id:py
#punc:[
#id:y
#punc:]
#punc:]
#op:=
#id:y
#punc:;
138:        x_match[py[y]] = y;
#id:y_match
#punc:[
#id:y
#punc:]
#op:=
#id:py
#punc:[
#id:y
#punc:]
#punc:;
139:        y_match[y] = py[y];
#key:if
#punc:(
#id:px
#punc:[
#id:y_match
#punc:[
#id:y
#punc:]
#punc:]
#op:!=
#op:-
#integer:2
#punc:)
#id:toggle
#punc:(
#id:px
#punc:[
#id:y_match
#punc:[
#id:y
#punc:]
#punc:]
#punc:)
#punc:;
140:        if(px[y_match[y]]!=-2) toggle(px[y_match[y]]);
#punc:}
141:    }
142:
 n = |L| = |R|, id of nodes start with 1143:*/
#key:int
#id:init
#punc:(
#key:int
#id:_n
#punc:)
#punc:{
144:    int init(int _n){
#id:n
#op:=
#id:_n
#punc:;
145:        n = _n;
#key:for
#punc:(
#key:int
#id:i
#op:=
#integer:0
#punc:;
#id:i
#op:<=
#id:n
#punc:;
#id:i
#op:++
#punc:)
#punc:{
146:        for(int i=0; i<=n; i++){
#key:for
#punc:(
#key:int
#id:j
#op:=
#integer:0
#punc:;
#id:j
#op:<=
#id:n
#punc:;
#id:j
#op:++
#punc:)
147:            for(int j=0; j<=n; j++)
#id:G
#punc:[
#id:i
#punc:]
#punc:[
#id:j
#punc:]
#op:=
#integer:0
#punc:;
148:                G[i][j] = 0;
#punc:}
149:        }
#punc:}
150:    }
151:
#key:int
#id:add_edge
#punc:(
#key:int
#id:a
#punc:,
#key:int
#id:b
#punc:,
#id:T
#id:c
#punc:)
#punc:{
#id:G
#punc:[
#id:a
#punc:]
#punc:[
#id:b
#punc:]
#op:=
#id:c
#punc:;
#punc:}
152:    int add_edge(int a, int b, T c){ G[a][b] = c; }
153:
#key:int
#id:dfs
#punc:(
#key:int
#id:x
#punc:)
#punc:{
154:    int dfs(int x){
#key:for
#punc:(
#key:int
#id:y
#op:=
#integer:1
#punc:;
#id:y
#op:<=
#id:n
#punc:;
#id:y
#op:++
#punc:)
#punc:{
155:        for(int y=1; y<=n; y++){
#key:if
#punc:(
#id:py
#punc:[
#id:y
#punc:]
#punc:)
#key:continue
#punc:;
156:            if(py[y]) continue;
#id:T
#id:slack
#op:=
#id:lx
#punc:[
#id:x
#punc:]
#op:+
#id:ly
#punc:[
#id:y
#punc:]
#op:-
#id:G
#punc:[
#id:x
#punc:]
#punc:[
#id:y
#punc:]
#punc:;
157:            T slack = lx[x] + ly[y] - G[x][y];
#key:if
#punc:(
#id:fabs
#punc:(
#id:slack
#punc:)
#op:<
#id:eps
#punc:)
#punc:{
158:            if(fabs(slack) < eps){
#id:py
#punc:[
#id:y
#punc:]
#op:=
#id:x
#punc:;
159:                py[y] = x;
#key:if
#punc:(
#id:y_match
#punc:[
#id:y
#punc:]
#op:==
#integer:0
#punc:)
#punc:{
160:                if(y_match[y]==0){
#id:toggle
#punc:(
#id:y
#punc:)
#punc:;
161:                    toggle(y);
#key:return
#key:true
#punc:;
162:                    return true;
#punc:}
163:                }
#key:else
#punc:{
164:                else{
#key:if
#punc:(
#id:px
#punc:[
#id:y_match
#punc:[
#id:y
#punc:]
#punc:]
#punc:)
#key:continue
#punc:;
165:                    if(px[y_match[y]]) continue;
#id:px
#punc:[
#id:y_match
#punc:[
#id:y
#punc:]
#punc:]
#op:=
#id:y
#punc:;
166:                    px[ y_match[y] ] = y;
#key:if
#punc:(
#id:dfs
#punc:(
#id:y_match
#punc:[
#id:y
#punc:]
#punc:)
#punc:)
#key:return
#integer:1
#punc:;
167:                    if(dfs(y_match[y])) return 1;
#punc:}
168:                }
#punc:}
169:            }
#key:else
#key:if
#punc:(
#id:y_slack
#punc:[
#id:y
#punc:]
#op:>
#id:slack
#punc:)
#punc:{
170:            else if(y_slack[y] > slack){
#id:y_slack
#punc:[
#id:y
#punc:]
#op:=
#id:slack
#punc:;
171:                y_slack[y] = slack;
#id:y_par
#punc:[
#id:y
#punc:]
#op:=
#id:x
#punc:;
172:                y_par[y] = x;
#punc:}
173:            }
#punc:}
174:        }
#key:return
#key:false
#punc:;
175:        return false;
#punc:}
176:    }
177:
 update lx, ly with x'y_slack 178:*/
#key:void
#id:update
#punc:(
#id:vector
#op:<
#key:int
#op:>
#op:&
#id:Y
#punc:)
#punc:{
179:    void update(vector<int>& Y){
#id:Y
#punc:.
#id:clear
#punc:(
#punc:)
#punc:;
180:        Y.clear();
#id:T
#id:d
#op:=
#id:INF
#punc:;
181:        T d = INF;
#key:for
#punc:(
#key:int
#id:i
#op:=
#integer:1
#punc:;
#id:i
#op:<=
#id:n
#punc:;
#id:i
#op:++
#punc:)
#key:if
#punc:(
#op:!
#id:py
#punc:[
#id:i
#punc:]
#punc:)
#id:d
#op:=
#id:min
#punc:(
#id:d
#punc:,
#id:y_slack
#punc:[
#id:i
#punc:]
#punc:)
#punc:;
182:        for(int i=1; i<=n; i++) if(!py[i]) d = min(d, y_slack[i]);
183:
#key:for
#punc:(
#key:int
#id:i
#op:=
#integer:1
#punc:;
#id:i
#op:<=
#id:n
#punc:;
#id:i
#op:++
#punc:)
#punc:{
184:        for(int i=1; i<=n; i++){
#key:if
#punc:(
#id:px
#punc:[
#id:i
#punc:]
#punc:)
#id:lx
#punc:[
#id:i
#punc:]
#op:-
#op:=
#id:d
#punc:;
185:            if(px[i]) lx[i] -= d;
#key:if
#punc:(
#id:py
#punc:[
#id:i
#punc:]
#punc:)
#id:ly
#punc:[
#id:i
#punc:]
#op:+
#op:=
#id:d
#punc:;
186:            if(py[i]) ly[i] += d;
#key:else
#punc:{
187:            else{
#id:y_slack
#punc:[
#id:i
#punc:]
#op:-
#op:=
#id:d
#punc:;
188:                y_slack[i] -= d;
#key:if
#punc:(
#id:y_slack
#punc:[
#id:i
#punc:]
#op:==
#integer:0
#punc:)
#id:Y
#punc:.
#id:push_back
#punc:(
#id:i
#punc:)
#punc:;
189:                if(y_slack[i]==0) Y.push_back(i);
#punc:}
190:            }
#punc:}
191:        }
#punc:}
192:    }
193:
 You have to assert G has a perfect matching. 194:*/
#id:T
#id:km
#punc:(
#punc:)
#punc:{
195:    T km(){
#key:for
#punc:(
#key:int
#id:i
#op:=
#integer:0
#punc:;
#id:i
#op:<=
#id:n
#punc:;
#id:i
#op:++
#punc:)
#id:x_match
#punc:[
#id:i
#punc:]
#op:=
#id:y_match
#punc:[
#id:i
#punc:]
#op:=
#integer:0
#punc:;
196:        for(int i=0; i<=n; i++) x_match[i] = y_match[i] = 0;
#key:for
#punc:(
#key:int
#id:i
#op:=
#integer:1
#punc:;
#id:i
#op:<=
#id:n
#punc:;
#id:i
#op:++
#punc:)
#punc:{
197:        for(int i=1; i<=n; i++){
#id:lx
#punc:[
#id:i
#punc:]
#op:=
#id:G
#punc:[
#id:i
#punc:]
#punc:[
#integer:1
#punc:]
#punc:,
#id:ly
#punc:[
#id:i
#punc:]
#op:=
#integer:0
#punc:;
198:            lx[i] = G[i][1], ly[i] = 0;
#key:for
#punc:(
#key:int
#id:j
#op:=
#integer:1
#punc:;
#id:j
#op:<=
#id:n
#punc:;
#id:j
#op:++
#punc:)
199:            for(int j=1; j<=n; j++)
#id:lx
#punc:[
#id:i
#punc:]
#op:=
#id:max
#punc:(
#id:lx
#punc:[
#id:i
#punc:]
#punc:,
#id:G
#punc:[
#id:i
#punc:]
#punc:[
#id:j
#punc:]
#punc:)
#punc:;
200:                lx[i] = max(lx[i], G[i][j]);
#punc:}
201:        }
202:
#key:for
#punc:(
#key:int
#id:i
#op:=
#integer:1
#punc:;
#id:i
#op:<=
#id:n
#punc:;
#id:i
#op:++
#punc:)
#punc:{
203:        for(int i=1; i<=n; i++){
#key:for
#punc:(
#key:int
#id:j
#op:=
#integer:0
#punc:;
#id:j
#op:<=
#id:n
#punc:;
#id:j
#op:++
#punc:)
#id:y_slack
#punc:[
#id:j
#punc:]
#op:=
#id:INF
#punc:;
204:            for(int j=0; j<=n; j++) y_slack[j] = INF;
#key:for
#punc:(
#key:int
#id:j
#op:=
#integer:0
#punc:;
#id:j
#op:<=
#id:n
#punc:;
#id:j
#op:++
#punc:)
#id:px
#punc:[
#id:j
#punc:]
#op:=
#id:py
#punc:[
#id:j
#punc:]
#op:=
#integer:0
#punc:;
205:            for(int j=0; j<=n; j++) px[j] = py[j] = 0;
#id:px
#punc:[
#id:i
#punc:]
#op:=
#op:-
#integer:2
#punc:;
206:            px[i] = -2;
#key:if
#punc:(
#id:dfs
#punc:(
#id:i
#punc:)
#punc:)
#key:continue
#punc:;
207:            if(dfs(i)) continue;
208:            // update();
209:
210:            // adjust labeling until finding an augmenting path
#key:bool
#id:find
#op:=
#key:false
#punc:;
211:            bool find = false;
#key:while
#punc:(
#op:!
#id:find
#punc:)
#punc:{
212:            while(!find){
#id:vector
#op:<
#key:int
#op:>
#id:Y
#punc:;
213:                vector<int> Y;
#id:update
#punc:(
#id:Y
#punc:)
#punc:;
214:                update(Y);
#key:for
#punc:(
#id:auto
#id:y
#punc::
#id:Y
#punc:)
#punc:{
215:                for(auto y:Y){
#key:if
#punc:(
#id:find
#punc:)
#key:break
#punc:;
216:                    if(find) break;
217:
#id:py
#punc:[
#id:y
#punc:]
#op:=
#id:y_par
#punc:[
#id:y
#punc:]
#punc:;
218:                    py[y] = y_par[y];
#key:if
#punc:(
#id:y_match
#punc:[
#id:y
#punc:]
#op:==
#integer:0
#punc:)
#punc:{
219:                    if(y_match[y]==0){
#id:toggle
#punc:(
#id:y
#punc:)
#punc:;
220:                        toggle(y);
#id:find
#op:=
#key:true
#punc:;
221:                        find = true;
#punc:}
222:                    }
#key:else
#punc:{
223:                    else{
#id:px
#punc:[
#id:y_match
#punc:[
#id:y
#punc:]
#punc:]
#op:=
#id:y
#punc:;
224:                        px[ y_match[y] ] = y;
#key:if
#punc:(
#id:dfs
#punc:(
#id:y_match
#punc:[
#id:y
#punc:]
#punc:)
#punc:)
#id:find
#op:=
#key:true
#punc:;
225:                        if(dfs(y_match[y])) find = true;
#punc:}
226:                    }
#punc:}
227:                }
#punc:}
228:            }
#punc:}
229:        }
230:
#id:T
#id:ans
#op:=
#integer:0
#punc:;
231:        T ans = 0;
#key:for
#punc:(
#key:int
#id:x
#op:=
#integer:1
#punc:;
#id:x
#op:<=
#id:n
#punc:;
#id:x
#op:++
#punc:)
#id:ans
#op:+
#op:=
#id:G
#punc:[
#id:x
#punc:]
#punc:[
#id:x_match
#punc:[
#id:x
#punc:]
#punc:]
#punc:;
232:        for(int x=1; x<=n; x++) ans += G[x][x_match[x]];
#key:return
#id:ans
#punc:;
233:        return ans;
#punc:}
234:    }
235:
#key:void
#id:dump
#punc:(
#id:vector
#op:<
#id:pair
#op:<
#key:int
#punc:,
#key:int
#op:>
#op:>
#op:&
#id:ans
#punc:)
#punc:{
236:    void dump(vector<pair<int,int>>& ans){
#key:for
#punc:(
#key:int
#id:i
#op:=
#integer:1
#punc:;
#id:i
#op:<=
#id:n
#punc:;
#id:i
#op:++
#punc:)
#key:if
#punc:(
#id:G
#punc:[
#id:i
#punc:]
#punc:[
#id:x_match
#punc:[
#id:i
#punc:]
#punc:]
#op:!=
#integer:0
#punc:)
#punc:{
237:        for(int i=1; i<=n; i++) if(G[i][x_match[i]]!=0){
#id:ans
#punc:.
#id:push_back
#punc:(
#punc:{
#id:i
#punc:,
#id:x_match
#punc:[
#id:i
#punc:]
#punc:}
#punc:)
#punc:;
238:            ans.push_back({i, x_match[i]});
#punc:}
239:        }
#punc:}
240:    }
#punc:}
#punc:;
241:};
#id:KM
#op:<
#key:double
#op:>
#id:km
#punc:;
242:KM<double> km;
#key:double
#id:dx
#punc:[
#id:maxn
#punc:]
#punc:,
#id:dy
#punc:[
#id:maxn
#punc:]
#punc:;
243:double dx[maxn], dy[maxn];
#key:double
#id:tx
#punc:[
#id:maxn
#punc:]
#punc:,
#id:ty
#punc:[
#id:maxn
#punc:]
#punc:;
244:double tx[maxn], ty[maxn];
#key:double
#id:cal
#punc:(
#key:double
#id:x
#punc:,
#key:double
#id:y
#punc:)
#punc:{
#key:return
#id:sqrt
#punc:(
#id:x
#op:*
#id:x
#op:+
#id:y
#op:*
#id:y
#punc:)
#punc:;
#punc:}
245:double cal(double x, double y){ return sqrt(x*x+y*y); }
#key:int
#id:main
#punc:(
#punc:)
246:int main()
#punc:{
247:{
#key:int
#id:n
#punc:,
#id:first
#op:=
#key:true
#punc:;
248:    int n, first = true;
#key:while
#punc:(
#key:scanf
#punc:(
#string:%d
#punc:,
#op:&
#id:n
#punc:)
#op:==
#integer:1
#punc:)
#punc:{
249:    while(scanf("%d",&n)==1){
#key:for
#punc:(
#key:int
#id:i
#op:=
#integer:1
#punc:;
#id:i
#op:<=
#id:n
#punc:;
#id:i
#op:++
#punc:)
#key:scanf
#punc:(
#string:%lf%lf
#punc:,
#op:&
#id:dx
#punc:[
#id:i
#punc:]
#punc:,
#op:&
#id:dy
#punc:[
#id:i
#punc:]
#punc:)
#punc:;
250:        for(int i=1; i<=n; i++) scanf("%lf%lf", &dx[i], &dy[i]);
#key:for
#punc:(
#key:int
#id:i
#op:=
#integer:1
#punc:;
#id:i
#op:<=
#id:n
#punc:;
#id:i
#op:++
#punc:)
#key:scanf
#punc:(
#string:%lf%lf
#punc:,
#op:&
#id:tx
#punc:[
#id:i
#punc:]
#punc:,
#op:&
#id:ty
#punc:[
#id:i
#punc:]
#punc:)
#punc:;
251:        for(int i=1; i<=n; i++) scanf("%lf%lf", &tx[i], &ty[i]);
252:
#id:km
#punc:.
#id:init
#punc:(
#id:n
#punc:)
#punc:;
253:        km.init(n);
#key:for
#punc:(
#key:int
#id:i
#op:=
#integer:1
#punc:;
#id:i
#op:<=
#id:n
#punc:;
#id:i
#op:++
#punc:)
#punc:{
254:        for(int i=1; i<=n; i++){
#key:for
#punc:(
#key:int
#id:j
#op:=
#integer:1
#punc:;
#id:j
#op:<=
#id:n
#punc:;
#id:j
#op:++
#punc:)
#punc:{
255:            for(int j=1; j<=n; j++){
#key:double
#id:tmp
#op:=
#id:cal
#punc:(
#punc:(
#id:dx
#punc:[
#id:i
#punc:]
#op:-
#id:tx
#punc:[
#id:j
#punc:]
#punc:)
#punc:,
#punc:(
#id:dy
#punc:[
#id:i
#punc:]
#op:-
#id:ty
#punc:[
#id:j
#punc:]
#punc:)
#punc:)
#punc:;
256:                double tmp = cal((dx[i]-tx[j]), (dy[i]-ty[j]));
#id:km
#punc:.
#id:add_edge
#punc:(
#id:i
#punc:,
#id:j
#punc:,
#op:-
#id:tmp
#punc:)
#punc:;
257:                km.add_edge(i, j, -tmp);
#punc:}
258:            }
#punc:}
259:        }
#key:if
#punc:(
#op:!
#id:first
#punc:)
#key:puts
#punc:(
#string:
#punc:)
#punc:;
260:        if(!first) puts("");
#key:else
#id:first
#op:=
#key:false
#punc:;
261:        else first = false;
#id:km
#punc:.
#id:km
#punc:(
#punc:)
#punc:;
262:        km.km();
#key:for
#punc:(
#key:int
#id:i
#op:=
#integer:1
#punc:;
#id:i
#op:<=
#id:n
#punc:;
#id:i
#op:++
#punc:)
#key:printf
#punc:(
#string:%d\n
#punc:,
#id:km
#punc:.
#id:x_match
#punc:[
#id:i
#punc:]
#punc:)
#punc:;
263:        for(int i=1; i<=n; i++) printf("%d\n",km.x_match[i]);
#punc:}
264:    }
#key:return
#integer:0
#punc:;
265:    return 0;
#punc:}
266:}
IDDerror
Error at line 267: 45a2
#sci:23.34E+34
268:23.34E+34
#sci:23.34E-34
269:23.34E-34
#sci:23.34e-34
270:23.34e-34
#sci:23.34e+34
271:23.34e+34
#sci:23.34e34
272:23.34e34
#sci:23.34E34
273:23.34E34
Error at line 274: 23.34E23.4e-34
Error at line 275: 23.34E234e-34
Error at line 276: 234.2342.34E34
#sci:234.43E234
#double:.234
277:234.43E234.234
