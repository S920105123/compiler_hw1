#pragma source on
#pragma token on
/* 23.4
1234
23@23

i can't see you */ hi hi = qq
// 234 sdf  ewe int double void
''
""
" \" " av c" "sdf "
#pragma token on
#pragma source off
00000.000000
02.
aa}bb
#pragma source on
aa_bb_sd__{sdfsdf+dfsdfsd+dsf}
*((apple)))
12.34
123.34e234
&
for(int i=0; i>oo; i+=2oo){
    cout << i*pow(oo, oo);
}
.00
.10
23.23e324/34     good
23.23e324++34   good
23.23e324--34   good
23.23e324&34    good
23.23e324&34    good
23.23e324[34    good
abc+.sdf        good
abc+.sdf        good
abc12.34        good    id:abc12 double.34
123..           good
abcc*+q0_0q+*abcc      good
:) good
:( good
--(GGqaq)-- good
2.e++324                not sure
234.3324e-324}3.234e-009 good
234.3324e-324:3.234e-009 good
234.3324e-324;3.234e-009 good
234.3324e-324,3.234e-009 good
234.3324e-324[3.234e-009 good
234.3324e-324]3.234e-009 good
234.3324e-324(3.234e-009 good
234.3324e-324)3.234e-009 good
234.3324e-324{3.234e-009 good
234.3324e-324}3.234e-009 good
234.3324e-324+3.234e-009 good
234.3324e-324-3.234e-009 good
234.3324e-324*3.234e-009 good
234.3324e-324/3.234e-009 good
234.3324e-324%3.234e-009 good
234.3324e-324++3.234e-009 good
234.3324e-324--3.234e-009 good
234.3324e-324<3.234e-009 good
234.3324e-324<=3.234e-009 good
234.3324e-324>3.234e-009 good
234.3324e-324>=3.234e-009 good
234.3324e-324==3.234e-009 good
234.3324e-324!=3.234e-009 good
234.3324e-324=3.234e-009 good
234.3324e-324&&3.234e-009 good
234.3324e-324&3.234e-009 good
234.3324e-324||3.234e-009 good
234.3324e-324!3.234e-009 good
234.3324e-324&3.234e-009 good
234.3324e-324|3.234e-009 not sure
234.3324e-324^3.234e-009 not sure
234.3324e-324?3.234e-009 not sure
234.3324e-324@3.234e-009 not sure Error 234.3324e-324@3.234e-009 or @3.234e-009
234.3324e-324~3.234e-009 not sure Error 234.3324e-324@3.234e-009
se3.343
2.e343          not sure
"asdb           error
123234@123      error int: 123213 , Error@123
45ab2           error
10.56.23        error
12.3E+asb2      error
â€œabcdefg        error
@error          error
#prag           error
abc@abc12       error  Error abc@abc12
23.23E+333@     error
23.23E+@        error
23.E@           error
.23.            error
23.23.34.345.   error
123..234        error
23.23e324#34    error
23.23e324.34    error -> good
abc#sdf         error
1.12.1.1        error
123.E+2abc      good
abc{abc         good
abc@abc         error Error abc@abc
234#3333        error Error #3333
234.e34324#3333 not sure Error #3333
'@'
'\n'
'\t'
' '
'23423423'
"sdfsd"sdfs"
"abc" "dfef"
"avc\"
struct Node{
    Node* left, *right;
    int val;
    Node(int _val):left(NULL), right(NULL), val(v){}

    static Node* build(int l, int r){
        if(l==r) return new Node(d[id]);
        else{
            int mid = (l+r);
            Node* l = new Node;
            node->l = build(l, mid);
            node->r = build(mid+1, r);
        }
    }
};
using namespace std;

const double INF = DBL_MAX;
const double eps = 1e-10;
const int maxn = 100+10;
template<class T>
struct KM
{
    T G[maxn][maxn];
    T lx[maxn], ly[maxn], y_slack[maxn];
    int x_match[maxn], y_match[maxn];
    int px[maxn], py[maxn];  // keep augmenting path
    int y_par[maxn]; // the x making the lowest slack to y
    int n;

    void toggle(int y){
        x_match[py[y]] = y;
        y_match[y] = py[y];
        if(px[y_match[y]]!=-2) toggle(px[y_match[y]]);
    }

    /* n = |L| = |R|, id of nodes start with 1*/
    int init(int _n){
        n = _n;
        for(int i=0; i<=n; i++){
            for(int j=0; j<=n; j++)
                G[i][j] = 0;
        }
    }

    int add_edge(int a, int b, T c){ G[a][b] = c; }

    int dfs(int x){
        for(int y=1; y<=n; y++){
            if(py[y]) continue;
            T slack = lx[x] + ly[y] - G[x][y];
            if(fabs(slack) < eps){
                py[y] = x;
                if(y_match[y]==0){
                    toggle(y);
                    return true;
                }
                else{
                    if(px[y_match[y]]) continue;
                    px[ y_match[y] ] = y;
                    if(dfs(y_match[y])) return 1;
                }
            }
            else if(y_slack[y] > slack){
                y_slack[y] = slack;
                y_par[y] = x;
            }
        }
        return false;
    }

    /* update lx, ly with x'y_slack */
    void update(vector<int>& Y){
        Y.clear();
        T d = INF;
        for(int i=1; i<=n; i++) if(!py[i]) d = min(d, y_slack[i]);

        for(int i=1; i<=n; i++){
            if(px[i]) lx[i] -= d;
            if(py[i]) ly[i] += d;
            else{
                y_slack[i] -= d;
                if(y_slack[i]==0) Y.push_back(i);
            }
        }
    }

    /* You have to assert G has a perfect matching. */
    T km(){
        for(int i=0; i<=n; i++) x_match[i] = y_match[i] = 0;
        for(int i=1; i<=n; i++){
            lx[i] = G[i][1], ly[i] = 0;
            for(int j=1; j<=n; j++)
                lx[i] = max(lx[i], G[i][j]);
        }

        for(int i=1; i<=n; i++){
            for(int j=0; j<=n; j++) y_slack[j] = INF;
            for(int j=0; j<=n; j++) px[j] = py[j] = 0;
            px[i] = -2;
            if(dfs(i)) continue;
            // update();

            // adjust labeling until finding an augmenting path
            bool find = false;
            while(!find){
                vector<int> Y;
                update(Y);
                for(auto y:Y){
                    if(find) break;

                    py[y] = y_par[y];
                    if(y_match[y]==0){
                        toggle(y);
                        find = true;
                    }
                    else{
                        px[ y_match[y] ] = y;
                        if(dfs(y_match[y])) find = true;
                    }
                }
            }
        }

        T ans = 0;
        for(int x=1; x<=n; x++) ans += G[x][x_match[x]];
        return ans;
    }

    void dump(vector<pair<int,int>>& ans){
        for(int i=1; i<=n; i++) if(G[i][x_match[i]]!=0){
            ans.push_back({i, x_match[i]});
        }
    }
};
KM<double> km;
double dx[maxn], dy[maxn];
double tx[maxn], ty[maxn];
double cal(double x, double y){ return sqrt(x*x+y*y); }
int main()
{
    int n, first = true;
    while(scanf("%d",&n)==1){
        for(int i=1; i<=n; i++) scanf("%lf%lf", &dx[i], &dy[i]);
        for(int i=1; i<=n; i++) scanf("%lf%lf", &tx[i], &ty[i]);

        km.init(n);
        for(int i=1; i<=n; i++){
            for(int j=1; j<=n; j++){
                double tmp = cal((dx[i]-tx[j]), (dy[i]-ty[j]));
                km.add_edge(i, j, -tmp);
            }
        }
        if(!first) puts("");
        else first = false;
        km.km();
        for(int i=1; i<=n; i++) printf("%d\n",km.x_match[i]);
    }
    return 0;
}
45a2
23.34E+34
23.34E-34
23.34e-34
23.34e+34
23.34e34
23.34E34
23.34E23.4e-34
23.34E234e-34
234.2342.34E34
234.43E234.234
